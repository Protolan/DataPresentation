package SetATD.RingedLinkedListPlan;

import SetATD.Exceptions.SetException;

// Множество на кольцевом списке
public class Set {
    //Класс узла, значению и следущий элемент
    private class Node {
        public int value;
        public Node next;

        public Node(int value, Node n) {
            this.value = value;
            next = n;
        }
    }

    private Node _tail;

    // Конструктор по умолчанию, инициализирует _tail
    public Set() {
        _tail = null;
    }

    // Копирующий конструктор
    private Set(Node to, Node from) {
        copyFrom(to, from);
    }

    public Set union(Set set) {
        // Если список этот же возвращает копию списка
        // Если оба списка пустых возвращаем пустой список
        // Если кто из списка пустой, возвращаем копию непустого списка
        // Если списки не пересекаются то мы просто последовательно копируем списки от меньшего к большего
        // Создаем новое пустое множество
        // Инициализируем хвост нового списка, присваеваем значение наименьшой tail.next из двух списков
        // Идем по спискам пока кто либо из них не станет пустым
        // Если значения равны, тогда мы берем любое, и продвигаемся дальше по двум спискам
        // Мы ищем наименьший элемент из двух список и копируем его следущим элементом
        // Когда мы берем наименьшей элемент из какого то списка то мы продвигаемся дальше только по этому списке
        // Если кто то из списков остался не пустым мы должны скопировать отуда все его элементы последовательно в конец
        return null;
    }

    public Set intersection(Set set) {
        // Если список этот же возвращает копию списка
        // Если хотя бы один из списков пустой возвращаем пустой список
        // Если списки не пересекаются то возвращаем пустое множество
        // Создаем новое пустое множество
        // Ищем первый элемент пересечения, если элемент не найден, значит пересечений нет
        // Идем по спискам пока кто либо из них не станет пустым
        // Если значения равны, тогда мы берем любое, и продвигаемся дальше по двум спискам
        // Также в процессе поиска мы должны инициализовать хвост, если новый список еще не инициализрован
        // Если не равны мы продвигаем только наименьший из двух списков
        return null;
    }

    public Set difference(Set set) {
        // Если список этот же список или входящий список пустой возвращаем пустой список
        // Если исходный список пустой возвращает копию входящего
        // Если списки не пересекаются возвращает копию входящего списка
        // Создаем пустое множество
        // Идем по спискам пока кто либо из них не станет пустым
        // Если значения равны,  продвигаемся дальше по двум спискам
        // Если не равны мы продвигаем только наименьший из двух списков
        // Если значение из входящего списка становиться меньше чем в исходном значит заполняем его в новый список
        // Также в процессе поиска мы должны инициализовать хвост, если новый список еще не инициализрован
        // Если входящий список остался не пустым мы должны скопировать отуда все его элементы последовательно в конец списка
        return null;
    }

    public Set merge(Set set) {
        // Если список этот же возвращает копию списка
        // Если оба списка пустых возвращаем пустой список
        // Если кто из списка пустой, возвращаем копию непустого списка
        // Создаем новое пустое множество
        // Инициализируем хвост нового списка, присваеваем значение наименьшой tail.next из двух списков
        // Идем по спискам пока кто либо из них не станет пустым
        // Мы не проверяем случаи на равенство, так как это мердже
        // Мы ищем наименьший элемент из двух список и копируем его следущим элементом
        // Когда мы берем наименьшей элемент из какого то списка то мы продвигаемся дальше только по этому списке
        // Если кто то из списков остался не пустым мы должны скопировать отуда все его элементы последовательно в конец
        return null;
    }



    // Присваивает новое множество в исходное множество
    public void assign(Set set) {
        // Вызываем метод copyFrom
    }

    // Проверяет равны ли множества
    public boolean equal(Set set) {
        // Если это же множество или оба множества пустые значит они одинаковые
        // Проходим параллельно по узлам обоим списка, пока кто-либо не закончиться
        // Если хотя бы один узел не равен, то возвращаем false
        // Если один из списков или оба списка закончилось, результатом будет равенство следующих элементов обоих множеств
        return false;
    }

    // Возвращает то множество в котором есть это число
    public Set find(Set set, int value) {
        // Использует метод isMember, чтобы найти множество в котором есть это значение
        if (isMember(value)) return this;
        else if (set.isMember(value)) return set;
        else return null;
    }

    // Определяет есть ли число в множестве
    public boolean member(int value) {
        // Возвращает результат метода isMember
        return isMember(value);
    }

    // Минимальный элемент это голова
    public int min() {
        // Если список пустой выбросить исключение
        if (_tail == null) throw new SetException("Список пустой");
        return _tail.next.value;
    }

    // Максимальный элемент это последний элемент списка
    public int max() {
        // Если список пустой выбросить исключение
        if (_tail == null) throw new SetException("Список пустой");
        return _tail.value;
    }


    // Добавляет значение в множество, если его там нет, если нет ничего не делать
    public void insert(int value) {
        // Если список пустой, инициализируем новый tail, который ссылается сам на себя
        // Если значение больше хвоста(максимального), должен быть новый хвост, а старый сссылаеться на него
        // Ищем узел с нужным значением помощью findClosest
        // Если уже есть в множестве, ничего не делаем
        // Иначе вставляем новый элемент после ближайшего меньшего значения
    }

    // Удаляет значение из множества, если оно там есть, если нет ничего не делать
    public void delete(int value) {
        // Если список пустой, ничего не делаем
        // Случай, если удаляемое значение - хвост
        // Если элемент единственный, то просто обнуляет хвост
        // Ищем узел с нужным значением помощью findClosest
        // Если не найден ничего не делаем
    }


    // Обнуляет список
    public void makeNull() {
        // Обнуляем хвост
        _tail = null;
    }

    // Находит узел который, находит это же значение или ближайшее меньшее его значение
    private Node findClosest(Node start, int value) {
        // Если значение равно значению хвоста, возвращаем хвост
        return null;
    }

    // Определяет есть ли число в множестве
    private boolean isMember(int value) {
        // Если список пустой - FALSE
        // Вызываем метод findClosest от головы для поиска предыдущего узла с этим значением
        // Если список пустой или не найдее элемент с таким значением
        // Если все хорошо, значит принадлежит
        return true;
    }

    // Копирует множество
    private void copyFrom(Node start, Node end) {
        // Если копируемое множество пустое, то обнуляем список
        // Иначе инициализируем хвост и по узлам копируем взе значения
    }


    private boolean rangeNotInter(Set first, Set second) {
        return first._tail.value < second._tail.next.value || second._tail.value < first._tail.next.value;
    }

    // Вывод
    public void print() {
        if (_tail == null) {
            System.out.println("Список пустой");
            return;
        }
        Node current = _tail.next;
        do {
            System.out.print(current.value + " ");
            current = current.next;
        }
        while (current != _tail.next);
        System.out.println();
    }
}
