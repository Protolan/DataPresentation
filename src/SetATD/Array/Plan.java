package SetATD.Array;


public class Plan {
    // Класс для хранения диапазона
    private class Range {
        public Range(int start, int end) {
            this.start = start;
            this.end = end;
        }
        public int start;
        public int end;
    }

    // Класс для хранения позиции(index и бит в массиве)
    private class Position {
        public Position(int index, int bit) {
            this.index = index;
            this.bit = bit;
        }
        public int index;
        public int bit;
    }
    private Range _range; // границы
    private int[] _array;// массив, кооторый хранит информацию о доступных числах
    // Конструктор с параметрами x, y, в котором иницилизируем массив диапазона
    public Plan(int x, int y) {
        _range = new Range(x, y);
        _array = createRangeArray(_range);
    }


    //Получает общий диапазон
    // Создает диапазон с максимальной левой и максимальной правой границы
    private Range getUniteRange(Range first, Range second) {
        // Сравнивает границы диапазона и выбирает крайнии
        return null;
    }

    // Создает массив из диапазона
    private int[] createRangeArray(Range range) {
        // Длина массива это (end - start) / 32 +1
        return null;
    }

    // Возвращает позицию номера в множестве
    private Position findInArray(int value) {
        // Индекс массива это разница начало диапазона и значения деленное нацело на 32
        // Бит элемента массива это разница начало диапазона и значения остаток от деления на 32
        return null;
    }

    // Копирует множества из одного в другой, учитывая смещение
    private void copySet(Plan from, Plan to) {
        // Вычисляем стартовую позицию в массиве который копируется равный левому крайнему диапазона
        Position startPosition = to.findInArray(_range.start);
        // Смещение вычисляется номером биты найденной позиции
        // Учитывая смещении копируем из одного массива в другой и сдвигаем значении массива на нужную длину
        // При сдвиге учитываем что смещение идет и внутри элемента массива и переносит значения в следущую ячейку согласно смещению
        // Формула смещения
        //        if(startPosition.bit == 0) {
        //            for (int i = 0; i < from._array.length; i++) {
        //                to._array[startPosition.index + i] = from._array[i];
        //            }
        //        }
        //        else {
        //            int previous = 0;
        //            for (int i = 0; i < from._array.length; i++) {
        //                to._array[startPosition.index + i] = (from._array[i] >> startPosition.bit) | previous;
        //                previous = from._array[i] << (32 - startPosition.bit);
        //            }
        //        }

    }



    // Возвращает множество в которым есть все неповторяющиеся элементы из двух множеств
    public Set union(Set set) {
        // Если множество одно и тоже возвращаем его
        // Находим общий диапазон и создаем пустое множество с общим диапазоном

        // Вызываем метод copySet чтобы скопировать значение в новый массив из исходного

        // Вычисляем стартовую позицию в массиве который копируется равный левому крайнему диапазона
        // Смещение вычисляется номером биты найденной позиции

        // Учитывая смещении копируем с применение операции | из нового массива в другой и сдвигаем значении массива на нужную длину
        // При сдвиге учитываем что смещение идет и внутри элемента массива и переносит значения в следущую ячейку согласно смещению

        return null;
    }




    // Возвращает множество которое содержит общие элементы из двух множеств
    public Set intersection(Set set) {
        // Если множество одно и тоже возвращаем его
        // Находим общий диапазон и создаем пустое множество с общим диапазоном
        // Если диапазоны не пересекаются возвращает пустой массив с меньшим диапазоном
        // Вызываем метод copySet чтобы скопировать значение в новый массив из исходного

        // Вычисляем стартовую позицию в массиве который копируется равный левому крайнему диапазона
        // Смещение вычисляется номером биты найденной позиции

        // Учитывая смещении копируем с применение операции & из нового массива в другой и сдвигаем значении массива на нужную длину\
        // При сдвиге учитываем что смещение идет и внутри элемента массива и переносит значения в следущую ячейку согласно смещению
        return null;
    }

    // Возвращает множество которое содержит элементы которых нет в исходном множестве
    public Set difference(Set set) {
        // Если множество одно и тоже возвращаем пустое множество с таким же диапазоном
        // Находим общий диапазон и создаем пустое множество с общим диапазоном

        // Вызываем метод copySet чтобы скопировать значение в новый массив из исходного

        // Вычисляем стартовую позицию в массиве который копируется равный левому крайнему диапазона
        // Смещение вычисляется номером биты найденной позиции

        // Учитывая смещении копируем с применение операции & и ~ из нового массива в другой и сдвигаем значении массива на нужную длину
        // При сдвиге учитываем что смещение идет и внутри элемента массива и переносит значения в следущую ячейку согласно смещению
        // newSet._array[startPosition2.index + i] = (newSet._array[startPosition2.index + i] & ~set._array[i]);

        return null;
    }

    // Возвращает множество которое состоит из двух множеств, может быть выполнены если множество не имеют общих элементов
    public Set merge(Set set) {
        // Проверка множества на пересечении, выбрасываем исключении

        // Находим общий диапазон и создаем пустое множество с общим диапазоном

        // Вызываем метод copySet чтобы скопировать значение в новый массив из исходного

        // Вычисляем стартовую позицию в массиве который копируется равный левому крайнему диапазона
        // Смещение вычисляется номером биты найденной позиции

        // Учитывая смещении копируем с применение операции | из нового массива в другой и сдвигаем значении массива на нужную длину
        // При сдвиге учитываем что смещение идет и внутри элемента массива и переносит значения в следущую ячейку согласно смещению

        return null;
    }

    // Вызвает метод isMember
    // Проверяет содержит ли это множество значение
    public boolean member(int x) {
        return false;
    }


    // Возвращает множество в котором найден элемент
    public Set find(Set a, int x) {
        // Если перескаются выбросить исключение
        // Если первый isMember то возвращаем его
        // Если второй isMember возвращаем его
        // Инчае null
        return null;
    }

    private boolean isMember(int x) {
        /// Если outRange возрващет false
        // Вызываем findInArray, чтобы определить бит для проверки
        // Используем битовую маску с & если не нулевое значени то возвращаем 0
        return false;
    }

    // Добавляет значение в множество, если его там нет и оно попадает в диапазон множества
    public void insert(int x) {
        // Если outRange возрващет ничего не делаем
        // Вызываем findArray, чтобы определить позици для вставки
        var position = findInArray(x);
        // Используем битовую маску с | чтобы вставить элемент
        _array[position.index] |= 1 << 31 - position.bit;
    }

    // Удаляет значение из множества, если оно там есть, если нет ничего не делать
    public void delete(int x) {
        // Если outRange возрващет ничего не делаем
        // Вызываем findArray, чтобы определить позици для вставки
        var position = findInArray(x);
        // Используем битовую маску с & ~ чтобы вставить элемент
        _array[position.index] &= ~(1 << 31 - position.bit);
    }
    // Проверяет
    private boolean outRange(int x) {
        return x < _range.start || x > _range.end;
    }

    // Присваивает новое множество
    public void assign(Set set) {
        // Присваем range
        // Присваем array
        // Делаем копию
    }

    // Возвращает минимальный элемент
    public int min() {
        // Находим самый левый не нулевой элемент
        // Находим самый леый заполненный бит смещение вправо пока number != 1
        // Вычисляем значение по формуле _range.start + (32 * i) + bitNumber - 1;
        for (int i = 0; i < _array.length; i++) {
            if(_array[i] != 0) {
                int number = _array[i];
                int bitNumber = 0;
                while (number != 1) {
                    number >>= 1;
                    bitNumber++;
                }
                bitNumber = 32 - bitNumber;
                return _range.start + (32 * i) + bitNumber - 1;
            }
        }
        return 0;
    }

    // Возвращает максимальный элемент
    public int max() {
        // Находим самый левый не нулевой элемент
        // Находим самый правый заполненный бит смещение  вправо пока number % 2 == 0
        // Вычисляем значение по формуле _range.start + (32 * i) + bitNumber - 1;
        for (int i = _array.length - 1; i >= 0; i--) {
            if(i != 0) {
                int number = _array[i];
                int res = 0;
                while (number % 2 == 0) {
                    number >>= 1;
                    res++;
                }
                res = 32 - res;
                return _range.start + (32 * i) + res - 1;
            }
        }
        return 0;
    }

    // Возвращает true если множества равны
    public boolean equal(Set set) {
        // Если диапазоны не перескаються возвращаем falst
        // Находим общий диапазон
        // Вычисляем смещение для приведения к общему виду
        // Если при & все значений массива мы получим тот же результат, тогда возвращет true
        // Если хотя бы одно значение не совпадает тогда возвращает false
        return false;
    }


    public void makeNull() {
        // Обнуляем массмв
        for (int i = 0; i < _array.length; i++) {
            _array[i] = 0;
        }
    }

}
