package SetATD.LinkedListPlan;

import SetATD.Exceptions.SetException;

public class Set {
    private class Node {
        public int value;
        public Node next;

        public Node(int value, Node n) {
            this.value = value;
            next = n;
        }
    }

    private Node _head;


    public Set() {
        _head = null;
    }

    public Set(Set set) {
        copyFrom(set);
    }

    public Set union(Set set) {
        // Если список этот же возвращает копию списка
        // Если оба списка пустых возвращаем пустой список
        // Если кто из списка пустой, возвращаем копию непустого списка
        // Создаем новое пустое множество
        // Инициализируем голову нового списка, присваеваем значение наименьшой головы из двух списков
        // Идем по спискам пока кто либо из них не станет пустым
        // Если значения равны, тогда мы берем любое, и продвигаемся дальше по двум спискам
        // Мы ищем наименьший элемент из двух список и копируем его следущим элементом
        // Когда мы берем наименьшей элемент из какого то списка то мы продвигаемся дальше только по этому списке
        // Если кто то из списков остался не пустым мы должны скопировать отуда все его элементы последовательно в конец
        return null;
    }

    public Set intersection(Set set) {
        // Если список этот же возвращает копию списка
        // Если хотя бы один из списков пустой возвращаем пустой список
        // Создаем новое пустое множество
        // Ищем первый элемент пересечения, если элемент не найден, значит пересечений нет
        // Идем по спискам пока кто либо из них не станет пустым
        // Если значения равны, тогда мы берем любое, и продвигаемся дальше по двум спискам
        // Также в процессе поиска мы должны инициализовать голову, если новый список еще не инициализрован
        // Если не равны мы продвигаем только наименьший из двух списков
        return null;
    }

    public Set difference(Set set) {
        // Если список этот же список или входящий список пустой возвращаем пустой список
        // Если исходный список пустой возвращает копию входящего
        // Создаем пустое множество
        // Идем по спискам пока кто либо из них не станет пустым
        // Если значения равны,  продвигаемся дальше по двум спискам
        // Если не равны мы продвигаем только наименьший из двух списков
        // Если значение из входящего списка становиться меньше чем в исходном значит заполняем его в новый список
        // Также в процессе поиска мы должны инициализовать голову, если новый список еще не инициализрован
        // Если входящий список остался не пустым мы должны скопировать отуда все его элементы последовательно в конец списка
        return null;
    }

    public Set merge(Set set) {
        // Если список этот же возвращает копию списка
        // Если оба списка пустых возвращаем пустой список
        // Если кто из списка пустой, возвращаем копию непустого списка
        // Создаем новое пустое множество
        // Инициализируем голову нового списка, присваеваем значение наименьшой головы из двух списков
        // Идем по спискам пока кто либо из них не станет пустым
        // Мы не проверяем случаи на равенство, так как это мердже
        // Мы ищем наименьший элемент из двух список и копируем его следущим элементом
        // Когда мы берем наименьшей элемент из какого то списка то мы продвигаемся дальше только по этому списке
        // Если кто то из списков остался не пустым мы должны скопировать отуда все его элементы последовательно в конец
        return null;
    }


    // Присваивает новое множество
    // Необходимо скопировать ячейки то есть создать новые ноды
    public void assign(Set set) {
        copyFrom(set);
    }

    // Копирует входящее множества в исходное
    private void copyFrom(Set set) {
        // Если входящее множество пустое, то обнуляет список
        // Инициализируем голову, с таким же значение
        // Пробегаемся по входящему списку и копирует поэлементно
    }


    public boolean equal(Set set) {
        // Пробегается паралельно по двум спискам пока кто либо и них не станет пустым
        // Кажду итерация проверяем на равенство, если хотя бы один не равен, то возвращаем false
        // Обас списка должны были закончиться, проверяем что они оба равны null
        return false;
    }

    public Set find(Set set, int value) {
        // Вызываем приватный isMember и возвращает первый список в котором найден
        if (isMember(value)) return this;
        else if (set.isMember(value)) return set;
        else return null;
    }

    public boolean member(int value) {
        // Вызываем метод findClosest
        // Если позиция найден, возращаем true иначе false
        Node closest = findClosest(value);
        if (closest == null || closest.value != value) return false;
        return true;
    }

    // Минимальный элемент это голова
    public int min() {
        // Если список пустой выбросить исключение
        if (_head == null) throw new SetException("Список пустой");
        return _head.value;
    }

    // Максимальный элемент это последний элемент списка
    public int max() {
        // Если список пустой выбросить исключение
        if (_head == null) throw new SetException("Список пустой");
        // До ходим до последного узла и возвращаем его
        Node current = _head;
        while (current.next != null) {
            current = current.next;
        }
        return current.value;
    }


    // Добавляет значение в множество, если его там нет, если нет ничего не делать
    public void insert(int value) {
        // Используем метод closestNode, чтобы найти позиции для вставки
        Node closestNode = findClosest(value);
        // Если список пустой или новое значение самое маленькое, тогда мы создаем новую голову
        // Если уже есть в множестве ничего не делаем
        closestNode.next = new Node(value, closestNode.next);
    }

    // Удаляет значение из множества, если оно там есть, если нет ничего не делать
    public void delete(int value) {
        // Если удаляемое значение голова, то голова равны следущему элементу после нее
        // Используем метод closestNode, чтобы найти позиции для удаления
        Node closestNode = findClosest(value);
        // Если элемента нет в множестве, тогда ничего не делаем дальше
        // Ищем предыдущий элемент, для удаления
    }

    public void makeNull() {
        _head = null;
    }

    // Находит узел который находит предыдущий элемент к этому значению
    // Если следущий элемент найденного равен числу значит число найдено
    // Может вернуть null, если нет головы(список пустой) или число
    private Node findClosest(int value) {
        // Пробегаемся по связному списку
        // Если текущее значение больше или равно числу возвращаем предыдущее к нему
        // Если список закончился возвращаем предыдущий
        Node previous = null;
        Node current = _head;
        while (current != null && current.value <= value) {
            previous = current;
            current = current.next;
        }
        return previous;
    }

    private boolean isMember(int value) {
        return true;
    }

    // Вывод
    public void print() {
        if (_head == null) {
            System.out.println("Список пустой");
            return;
        }
        Node current = _head;
        while (current != null) {
            System.out.print(current.value + " ");
            current = current.next;
        }
        System.out.println();
    }
}
